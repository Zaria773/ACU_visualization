# ACU 数据库 12.1 API 分析总结

> 基于 `.kilocode/数据库/12.1index.js` 的代码分析
> 用于可视化表格前端开发参考

---

## 1. 脚本标识

```javascript
const UNIQUE_SCRIPT_ID = 'shujuku_v104';
const SCRIPT_ID_PREFIX_ACU = UNIQUE_SCRIPT_ID;
```

所有存储键都以此前缀开头。

---

## 2. 公开 API (AutoCardUpdaterAPI)

API 挂载在顶层窗口：`topLevelWindow.AutoCardUpdaterAPI`

### 2.1 数据获取

| 方法 | 说明 | 返回值 |
|------|------|--------|
| `exportTableAsJson()` | 获取合并后的表格数据 | `Object` (currentJsonTableData_ACU) |
| `getTableTemplate()` | 获取当前模板数据 | `Object` (解析后的 TABLE_TEMPLATE_ACU) |
| `getPlotPresets()` | 获取剧情预设列表 | `Array` |
| `getCurrentPlotPreset()` | 获取当前使用的预设名 | `string` |
| `getPlotPresetNames()` | 获取预设名称数组 | `string[]` |
| `getTemplatePresetNames()` | 获取模板预设名称列表 | `string[]` |

### 2.2 数据操作

| 方法 | 说明 | 参数 |
|------|------|------|
| `importTableAsJson(jsonString)` | 导入并覆盖表格数据 | JSON 字符串 |
| `triggerUpdate()` | 触发手动更新 | 无 |
| `manualUpdate()` | 等同于点击"立即手动更新"按钮 | 无 |
| `switchTemplatePreset(name)` | 切换模板预设 | 预设名称 |
| `switchPlotPreset(name)` | 切换剧情预设 | 预设名称 |
| `importTemplateFromData(data)` | 通过代码导入模板 | JSON 对象/字符串 |
| `importPlotPresetFromData(data, opts)` | 导入剧情预设 | JSON 对象/字符串 |

### 2.3 回调注册

| 方法 | 说明 |
|------|------|
| `registerTableUpdateCallback(fn)` | 注册表格更新回调 |
| `unregisterTableUpdateCallback(fn)` | 注销表格更新回调 |
| `registerTableFillStartCallback(fn)` | 注册填表开始回调 |
| `_notifyTableUpdate()` | 内部：通知更新 |
| `_notifyTableFillStart()` | 内部：通知填表开始 |

### 2.4 其他操作

| 方法 | 说明 |
|------|------|
| `openVisualizer()` | 打开可视化编辑器 |
| `openSettings()` | 打开设置面板 |
| `syncWorldbookEntries()` | 同步世界书注入条目 |
| `deleteInjectedEntries()` | 删除注入的世界书条目 |
| `exportJsonData()` | 导出 JSON 数据 |
| `mergeSummaryNow()` | 立即执行合并总结 |

---

## 3. 表格数据结构

### 3.1 表格对象 (sheet_*)

```typescript
interface TableSheet {
  name: string;           // 表格名称
  content: any[][];       // 二维数组内容，第一行为表头
  sourceData: {
    note: string;         // 表格说明
    initNode: string;     // 初始化节点
    insertNode: string;   // 插入节点
    updateNode: string;   // 更新节点
    deleteNode: string;   // 删除节点
  };
  updateConfig: {
    uiSentinel: -1;       // 标记位（-1 = 新语义）
    contextDepth: number; // 上下文深度 (-1=沿用UI)
    updateFrequency: number; // 更新频率 (-1=沿用UI, 0=禁用, N=每N层)
    batchSize: number;    // 批处理大小 (-1=沿用UI)
    skipFloors: number;   // 跳过楼层 (-1=沿用UI)
  };
  exportConfig: {
    enabled: boolean;
    splitByRow: boolean;
    entryName: string;
    entryType: string;
    keywords: string;
    preventRecursion: boolean;
    injectionTemplate: string;
  };
  orderNo?: number;       // 排序编号
}
```

### 3.2 updateConfig 语义说明

| 字段 | -1 含义 | 0 含义 | N>0 含义 |
|------|---------|--------|----------|
| `updateFrequency` | 沿用 UI 全局 | **禁用该表自动更新** | 每 N 层触发 |
| `contextDepth` | 沿用 UI 全局 | 沿用 UI（兼容旧版） | 使用该深度 |
| `batchSize` | 沿用 UI 全局 | 兜底到 UI 值 | 使用该批量 |
| `skipFloors` | 沿用 UI 全局 | 不跳过 | 跳过 N 层 |

---

## 4. 设置存储机制

### 4.1 存储层级（优先级由高到低）

1. **酒馆服务端设置**（主存）
   - 路径：`extensionSettings.__userscripts['shujuku_v104__userscript_settings_v1']`
   - 持久化函数：`saveSettingsDebounced()` 或 `saveSettings()`

2. **IndexedDB**（本地副本）
   - 数据库名：`shujuku_v104_config_v1`
   - Store 名：`kv`

3. **localStorage**（已废弃，仅迁移用）
   - 由 `FORBID_BROWSER_LOCAL_STORAGE_FOR_CONFIG_ACU = true` 禁止

### 4.2 Profile 化存储

设置按"隔离标识代码"分组存储：

```javascript
// 存储键格式
`shujuku_v104_profile_v1__${isolationCode}__settings`  // 设置
`shujuku_v104_profile_v1__${isolationCode}__template`  // 模板
```

### 4.3 全局元信息

```javascript
// 存储键
STORAGE_KEY_GLOBAL_META_ACU = 'shujuku_v104_globalMeta_v1';

// 结构
globalMeta_ACU = {
  activeIsolationCode: '',        // 当前激活的隔离标识
  isolationCodeList: [],          // 历史标识列表
  migratedLegacySingleStore: false // 是否已完成旧版迁移
};
```

---

## 5. 全局设置 (settings_ACU) - 未暴露

**注意**：`settings_ACU` 对象未通过 API 暴露，以下为其结构供参考：

```javascript
settings_ACU = {
  // API 配置
  apiConfig: { url, apiKey, model, useMainApi, max_tokens, temperature },
  apiMode: 'custom' | 'tavern',
  tavernProfile: '',

  // 更新参数（全局默认值）
  autoUpdateThreshold: 3,        // AI读取上下文层数
  autoUpdateFrequency: 2,        // 每N层自动更新一次 ★
  autoUpdateTokenThreshold: 0,   // 跳过更新最小回复长度
  updateBatchSize: 3,            // 每批次更新楼层数
  skipUpdateFloors: 0,           // 保留X层楼不更新
  autoUpdateEnabled: true,       // 启用自动更新

  // 数据隔离
  dataIsolationEnabled: false,
  dataIsolationCode: '',

  // 其他...
  charCardPrompt: [...],
  plotSettings: {...},
  tableApiPreset: '',
  plotApiPreset: '',
};
```

---

## 6. 聊天记录中的数据存储

### 6.1 数据隔离结构

每条消息可能包含以下字段：

```javascript
message.TavernDB_ACU_IsolatedData = {
  [isolationKey]: {
    independentData: { [sheetKey]: {...} },
    modifiedKeys: ['sheet_xxx', ...],      // 本楼层修改过的表
    updateGroupKeys: ['sheet_xxx', ...]    // 参与本次自动更新的表
  }
};

// 兼容旧字段
message.TavernDB_ACU_Identity = 'isolationCode';
message.TavernDB_ACU_IndependentData = {...};
message.TavernDB_ACU_ModifiedKeys = [...];
message.TavernDB_ACU_UpdateGroupKeys = [...];
```

### 6.2 指导表存储

```javascript
// chat[0] 中存储指导表（表头 + 配置，不含数据行）
message.TavernDB_ACU_InternalSheetGuide = {...};
```

---

## 7. 计算更新频率的完整逻辑

```typescript
// 第 7962-7974 行的逻辑还原
function getEffectiveUpdateFrequency(tableConfig: any, globalSettings: any): number {
  const rawFreq = Number.isFinite(tableConfig?.updateFrequency)
    ? tableConfig.updateFrequency
    : -1;

  if (rawFreq === -1) {
    // 沿用全局设置
    return globalSettings.autoUpdateFrequency || 2;
  }

  // rawFreq >= 0: 使用表级配置
  // 0 = 禁用该表自动更新
  // N > 0 = 每 N 层触发
  return rawFreq;
}
```

---

## 8. 获取运行时状态的难点

### 8.1 lastUpdatedAiFloor（未暴露）

```javascript
// 内部变量，未通过 API 暴露
let independentTableStates_ACU = {};
// 结构: { [sheetKey]: { lastUpdatedAiFloor: number } }
```

**解决方案**：遍历聊天记录的 `TavernDB_ACU_IsolatedData`，查找每个表最后被修改的楼层。

### 8.2 全局设置值（未暴露）

建议向数据库作者请求添加：

```javascript
window.AutoCardUpdaterAPI.getGlobalSettings = function() {
  return {
    autoUpdateFrequency: settings_ACU.autoUpdateFrequency,
    autoUpdateThreshold: settings_ACU.autoUpdateThreshold,
    updateBatchSize: settings_ACU.updateBatchSize,
    skipUpdateFloors: settings_ACU.skipUpdateFloors,
    autoUpdateEnabled: settings_ACU.autoUpdateEnabled
  };
};
```

---

## 9. 可视化表格的数据读取最佳实践

```typescript
// 1. 获取表格数据
const tableData = window.AutoCardUpdaterAPI.exportTableAsJson();

// 2. 获取模板配置（含 updateConfig）
const template = window.AutoCardUpdaterAPI.getTableTemplate();

// 3. 注册更新回调
window.AutoCardUpdaterAPI.registerTableUpdateCallback((newData) => {
  // 处理新数据
});

// 4. 计算每个表的有效更新频率
Object.keys(tableData).filter(k => k.startsWith('sheet_')).forEach(key => {
  const tableConfig = template?.[key]?.updateConfig || {};
  const rawFreq = tableConfig.updateFrequency ?? -1;

  let effectiveFreq: number | string;
  if (rawFreq === 0) effectiveFreq = '禁用';
  else if (rawFreq === -1) effectiveFreq = 2; // 全局默认
  else effectiveFreq = rawFreq;
});
```

---

## 10. 版本兼容性说明

| 版本差异 | 旧版本 (9.5) | 新版本 (10.5+/12.1) |
|----------|--------------|---------------------|
| updateConfig 沿用标志 | `0` = 沿用 UI | `-1` = 沿用 UI |
| updateFrequency=0 | 沿用 UI | **禁用该表** |
| Profile 存储 | 单份设置 | 按隔离标识分组 |
| 存储后端 | localStorage | 酒馆设置 + IndexedDB |

---

---

## 11. 从前端读取全局设置的方案

### 11.1 方案 A：直接读取 extensionSettings（推荐，只读）

全局设置存储在酒馆的 `extensionSettings.__userscripts` 中：

```typescript
/**
 * 从酒馆 extensionSettings 读取数据库全局设置
 * @returns 全局设置对象，或 null（未找到）
 */
function getGlobalSettings(): Record<string, any> | null {
  const context = window.parent.SillyTavern?.getContext?.();
  const userscripts = context?.extensionSettings?.__userscripts;

  if (!userscripts) return null;

  // 找到数据库的设置键（匹配版本号模式）
  const settingsKey = Object.keys(userscripts).find(k =>
    k.match(/shujuku_v\d+__userscript_settings_v1/)
  );

  if (!settingsKey || !userscripts[settingsKey]) return null;

  // 解析设置（可能是 JSON 字符串或对象）
  const raw = userscripts[settingsKey];
  return typeof raw === 'string' ? JSON.parse(raw) : raw;
}

// 使用示例
const settings = getGlobalSettings();
const globalFrequency = settings?.autoUpdateFrequency ?? 2;
```

**优点**：
- 无需修改数据库脚本
- 实时读取最新值

**缺点**：
- 只能读取，写入不会被数据库脚本同步感知
- 存储键可能随版本变化

---

### 11.2 方案 B：Profile 化存储读取（更精确）

设置按隔离标识分组存储，需要先获取当前激活的隔离码：

```typescript
function getProfiledSettings() {
  const context = window.parent.SillyTavern?.getContext?.();
  const userscripts = context?.extensionSettings?.__userscripts;

  // 1. 获取全局元信息
  const metaKey = 'shujuku_v104_globalMeta_v1';
  const globalMeta = userscripts?.[metaKey];
  const activeIsolationCode = globalMeta?.activeIsolationCode || '';

  // 2. 获取对应 profile 的设置
  const profileKey = `shujuku_v104_profile_v1__${activeIsolationCode}__settings`;
  return userscripts?.[profileKey] || null;
}
```

---

### 11.3 方案 C：劫持写入（高风险，不推荐）

理论上可以拦截数据库脚本的存储函数，但会造成：
- 版本兼容问题
- 数据一致性风险
- 维护困难

**不建议采用**。

---

### 11.4 方案 D：请求作者暴露 API（最佳长期方案）

建议向数据库作者请求添加以下 API：

```javascript
// 建议的 API 扩展
window.AutoCardUpdaterAPI.getGlobalSettings = function() {
  return {
    autoUpdateFrequency: settings_ACU.autoUpdateFrequency,
    autoUpdateThreshold: settings_ACU.autoUpdateThreshold,
    updateBatchSize: settings_ACU.updateBatchSize,
    skipUpdateFloors: settings_ACU.skipUpdateFloors,
    autoUpdateEnabled: settings_ACU.autoUpdateEnabled,
  };
};

window.AutoCardUpdaterAPI.updateGlobalSettings = function(patch) {
  Object.assign(settings_ACU, patch);
  saveSettingsDebounced(); // 触发持久化
};
```

---

### 11.5 推荐实现：综合方案

结合模板配置和全局设置读取：

```typescript
/**
 * 获取表格的有效更新频率
 * @param tableKey 表格键名（如 sheet_xxx）
 * @returns 更新频率数值，或 '禁用' / '全局(N)'
 */
function getEffectiveFrequency(tableKey: string): number | string {
  // 1. 从模板读取表级配置
  const template = window.AutoCardUpdaterAPI?.getTableTemplate?.();
  const tableConfig = template?.[tableKey]?.updateConfig;
  const rawFreq = tableConfig?.updateFrequency ?? -1;

  // 2. 根据值语义处理
  if (rawFreq === 0) return '禁用';
  if (rawFreq > 0) return rawFreq;

  // 3. rawFreq === -1，沿用全局设置
  const globalSettings = getGlobalSettings();
  const globalFreq = globalSettings?.autoUpdateFrequency ?? 2;
  return `全局(${globalFreq})`;
}
```

---

## 12. 获取 lastUpdatedAiFloor 的方案

`lastUpdatedAiFloor` 存储在 `independentTableStates_ACU` 内部变量中，未暴露。

### 12.1 解决方案：遍历聊天记录

```typescript
/**
 * 计算指定表格最后更新的 AI 楼层号
 * @param tableKey 表格键名
 * @returns AI 楼层号，或 null（未找到）
 */
function getLastUpdatedAiFloor(tableKey: string): number | null {
  const chat = window.parent.SillyTavern?.getContext?.()?.chat;
  if (!chat || !chat.length) return null;

  let lastAiFloor: number | null = null;
  let aiFloorCount = 0;

  for (let i = 0; i < chat.length; i++) {
    const msg = chat[i];

    // 统计 AI 楼层（非用户消息）
    if (!msg.is_user) {
      aiFloorCount++;
    }

    // 检查是否有该表的修改记录
    const isolatedData = msg.TavernDB_ACU_IsolatedData;
    if (isolatedData) {
      for (const tagData of Object.values(isolatedData) as any[]) {
        const modified = tagData?.modifiedKeys || [];
        const updated = tagData?.updateGroupKeys || [];
        if (modified.includes(tableKey) || updated.includes(tableKey)) {
          lastAiFloor = aiFloorCount;
        }
      }
    }
  }

  return lastAiFloor;
}
```

### 12.2 计算未记录楼层数

```typescript
function getUnrecordedFloors(tableKey: string): number {
  const lastFloor = getLastUpdatedAiFloor(tableKey);
  if (lastFloor === null) return 0;

  const chat = window.parent.SillyTavern?.getContext?.()?.chat;
  const totalAiFloors = chat?.filter((m: any) => !m.is_user).length || 0;

  return Math.max(0, totalAiFloors - lastFloor);
}
```

---

**文档创建时间**：2026-01-16
**文档更新时间**：2026-01-16
**数据库版本**：12.1 (shujuku_v104)

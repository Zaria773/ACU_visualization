## 批量单元格锁定功能 - 最终实现方案
### 用户原输入：
我想在设置面板的行为处增加一个锁定单元格的入口，点击后进入批量锁定模式。用户会进入主界面，点击单元格不会触发编辑而是触发锁定/解锁，对锁定的单元格可以增加某种视觉提示，单击即可切换某个单元格的锁与解锁状态。与正常不同的是导航栏会暂时多一个完成按钮，点击可以批量保存锁定的单元格，然后退出批量锁定状态。
### 需求确认

| 需求项 | 确认 |
|--------|------|
| 锁定粒度 | ✅ 单元格 + 整行快捷操作 |
| 持久化隔离 | ✅ 按聊天 contextFingerprint 隔离 |
| AI 数据保护 | ✅ 每次数据更新后自动 applyLocks |
| 视觉效果 | ✅ 仅在批量锁定模式下显示 |

---

### 实现任务清单

| # | 任务 | 状态 |
|---|------|------|
| 1 | 创建 `useCellLock.ts` composable | 待开始 |
| 2 | 修改 `useUIStore.ts` 添加 `isLockEditMode` | 待开始 |
| 3 | 修改 `DataCard.vue` 支持锁定模式交互 | 待开始 |
| 4 | 修改 `ActionBar.vue` 添加完成按钮 | 待开始 |
| 5 | 修改 `SettingsDialog.vue` 添加入口 | 待开始 |
| 6 | 添加锁定样式到 `data-card.scss` | 待开始 |
| 7 | 在 `useDataPersistence.ts` 调用 applyLocks | 待开始 |

---

### 文件变更清单

```
src/可视化表格/
├── composables/
│   ├── index.ts                    # [修改] 导出 useCellLock
│   └── useCellLock.ts              # [新增] 锁定管理器
│
├── stores/
│   └── useUIStore.ts               # [修改] +isLockEditMode
│
├── components/
│   ├── DataCard.vue                # [修改] 锁定模式交互
│   ├── ActionBar.vue               # [修改] 完成按钮
│   └── dialogs/
│       └── SettingsDialog.vue      # [修改] 入口按钮
│
├── composables/
│   └── useDataPersistence.ts       # [修改] applyLocks 调用
│
└── styles/components/
    └── data-card.scss              # [修改] 锁定样式
```

---

### 核心架构

```
┌─────────────────────────────────────────────────────────────┐
│                     useCellLock.ts                          │
├─────────────────────────────────────────────────────────────┤
│ 状态:                                                        │
│   pendingLocks: Map<table, Map<rowKey, Set<field>>>         │
│   (批量模式下的临时锁定，未保存)                              │
│                                                              │
│ 方法:                                                        │
│   toggleCellLock(table, rowKey, field)  // 切换单元格锁定   │
│   toggleRowLock(table, rowKey, headers, row)  // 切换整行   │
│   isCellLocked(table, rowKey, field)    // 检查是否锁定     │
│   isRowLocked(table, rowKey)            // 检查整行是否锁定  │
│   savePendingLocks()                    // 保存到 localStorage│
│   discardPendingLocks()                 // 丢弃未保存的锁定  │
│   applyLocks(table, data) → data        // 恢复被 AI 修改的值│
└─────────────────────────────────────────────────────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         ▼                   ▼                   ▼
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   DataCard      │ │   ActionBar     │ │ DataPersistence │
│ 点击切换锁定    │ │ 完成按钮保存    │ │ 数据更新时恢复  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

---

### 用户交互流程

```
1. 用户在设置面板点击「进入锁定模式」
   └→ uiStore.isLockEditMode = true
   └→ 关闭设置弹窗，显示主面板

2. 主面板变化：
   ├─ ActionBar 显示「完成」按钮
   ├─ DataCard 单元格显示锁定状态（锁图标/边框）
   └─ 单元格点击行为变为切换锁定

3. 用户点击单元格
   └→ cellLock.toggleCellLock() 或长按触发 toggleRowLock()

4. 用户点击「完成」
   ├→ cellLock.savePendingLocks()
   ├→ uiStore.isLockEditMode = false
   └→ toast 提示「锁定已保存」

5. AI 更新数据时（任何时刻）
   └→ useDataPersistence 内部调用 cellLock.applyLocks()
   └→ 被锁定的单元格值自动恢复
```

---

### 存储格式（与骰子可视化兼容）

```json
// localStorage key: acu_locked_fields_v2_{contextFingerprint}
{
  "重要人物表": {
    "姓名=张三": {
      "_fullRow": false,
      "_fields": { "好感度": "100", "信任": "80" },
      "_snapshot": null
    },
    "姓名=李四": {
      "_fullRow": true,
      "_fields": {},
      "_snapshot": { "姓名": "李四", "HP": "200", "状态": "正常" }
    }
  },
  "_lastAccess": 1736690000000
}
```

---

准备好后切换到 Code 模式开始实现。

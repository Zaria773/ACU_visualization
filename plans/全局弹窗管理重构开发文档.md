# 全局弹窗管理重构开发文档

## 📋 概述

将散落在各组件中的弹窗统一收归 `useUIStore` 管理，全部渲染在 `App.vue` 中。

---

## 📊 现状分析

### 当前弹窗分布

| 管理位置 | 弹窗数量 | 弹窗列表 |
|----------|----------|----------|
| **App.vue（全局）** | 6个 | SettingsDialog, InputFloorDialog, PurgeRangeDialog, ManualUpdateDialog, HistoryDialog, ContextMenu |
| **Dashboard.vue** | 2个 | RowEditDialog, HistoryDialog（重复！） |
| **PurgeRangeDialog** | 1个 | AdvancedPurgeDialog |
| **BallAppearancePanel** | 1个 | AvatarCropDialog |
| **AvatarManagerDialog** | 2个 | AvatarCropDialog, NodeLabelDialog |

### 主要问题

1. **重复组件**：`HistoryDialog` 在 App.vue 和 Dashboard.vue 各有一份
2. **移动端位置错误**：嵌套弹窗（如 AdvancedPurgeDialog）在移动端经常定位错误
3. **z-index 层级问题**：Dashboard 内弹窗被导航栏遮挡（需要 `.has-modal` hack）
4. **样式丢失**：Teleport 到父窗口后缺少主题类

---

## 🎯 目标架构

### useUIStore 扩展

```typescript
// 弹窗状态类型
interface DialogState<T = Record<string, unknown>> {
  visible: boolean;
  props: T;
}

// 弹窗注册表
interface DialogRegistry {
  settings: DialogState;
  inputFloor: DialogState<{ currentFloor: number }>;
  purgeRange: DialogState<{ maxFloor: number }>;
  advancedPurge: DialogState<{ initialStartFloor?: number; initialEndFloor?: number }>;
  manualUpdate: DialogState;
  history: DialogState<{ tableName: string; tableId: string; rowIndex: number; currentRowData: any }>;
  rowEdit: DialogState<{ tableName: string; tableId: string; rowIndex: number; currentRowData: any }>;
  avatarCrop: DialogState<{ imageData: string; onConfirm: (result: string) => void }>;
  avatarManager: DialogState;
  nodeLabel: DialogState<{ currentLabels: string[]; onConfirm: (labels: string[]) => void }>;
}

// Store Actions
openDialog(name: keyof DialogRegistry, props?: object): void
closeDialog(name: keyof DialogRegistry): void
closeAllDialogs(): void
```

### App.vue 结构

```vue
<template>
  <!-- 主界面 -->
  <div class="acu-wrapper" :class="themeClass">
    <!-- ... 现有内容 ... -->
  </div>

  <!-- 全局弹窗层 - 统一 Teleport 到父窗口 -->
  <Teleport :to="parentBody">
    <div class="acu-global-dialogs" :class="themeClass">
      <!-- 一级弹窗 -->
      <SettingsDialog v-if="dialogs.settings.visible" @close="closeDialog('settings')" />
      <HistoryDialog v-if="dialogs.history.visible" v-bind="dialogs.history.props" @close="closeDialog('history')" />
      <RowEditDialog v-if="dialogs.rowEdit.visible" v-bind="dialogs.rowEdit.props" @close="closeDialog('rowEdit')" />
      <!-- ... 其他弹窗 ... -->
    </div>
  </Teleport>
</template>
```

---

## ⚠️ 风险评估

### 高风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **Props 传递链断裂** | 弹窗无法接收正确参数 | 详细测试每个弹窗的所有 props |
| **事件回调丢失** | @confirm、@close 等事件失效 | 将回调函数存入 props，或使用 mitt 事件总线 |
| **主题类丢失** | 弹窗无样式 | 统一使用 `.acu-global-dialogs` 包裹并添加 themeClass |

### 中风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **嵌套弹窗调用链** | PurgeRange → AdvancedPurge 的打开逻辑需要改写 | 改为 `uiStore.openDialog('advancedPurge')` |
| **弹窗互斥逻辑** | 同时打开多个弹窗可能 UI 混乱 | 添加 `closeAllDialogs()` 逻辑 |

### 低风险项

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| **代码体积增加** | App.vue 变大 | 合理拆分，弹窗组件本身不变 |

---

## 📝 实施步骤

### 第一阶段：准备（低风险）

1. **扩展 useUIStore**
   - 添加 `dialogs` 状态对象
   - 添加 `openDialog`、`closeDialog`、`closeAllDialogs` 方法
   - 文件：`stores/useUIStore.ts`

2. **创建全局弹窗容器样式**
   - 添加 `.acu-global-dialogs` 样式
   - 确保主题类正确继承
   - 文件：`styles/overlays/dialogs.scss`

### 第二阶段：迁移 Dashboard 弹窗（中风险）

3. **移除 Dashboard 中的重复 HistoryDialog**
   - Dashboard 改为调用 `uiStore.openDialog('history', props)`
   - App.vue 中的 HistoryDialog 已存在，无需新增
   - 文件：`components/Dashboard.vue`

4. **迁移 RowEditDialog**
   - Dashboard 改为调用 `uiStore.openDialog('rowEdit', props)`
   - App.vue 添加 RowEditDialog
   - 文件：`components/Dashboard.vue`, `App.vue`

### 第三阶段：迁移嵌套弹窗（高风险）

5. **迁移 AdvancedPurgeDialog**
   - PurgeRangeDialog 改为调用 `uiStore.openDialog('advancedPurge')`
   - App.vue 添加 AdvancedPurgeDialog
   - 文件：`components/dialogs/PurgeRangeDialog.vue`, `App.vue`

6. **迁移头像相关弹窗**
   - AvatarCropDialog
   - AvatarManagerDialog
   - NodeLabelDialog
   - 文件：`components/settings/BallAppearancePanel.vue`, `components/dialogs/AvatarManagerDialog.vue`, `App.vue`

### 第四阶段：清理

7. **移除旧代码**
   - 删除各组件中的本地弹窗状态
   - 删除 `.has-modal` hack
   - 更新 ACU_DEV_GUIDE.md 规范

---

## 🧪 测试清单

每个弹窗迁移后需验证：

- [ ] PC端：弹窗正确显示
- [ ] PC端：弹窗关闭正常
- [ ] PC端：所有交互功能正常（输入、按钮、选择器等）
- [ ] 移动端：弹窗位置正确
- [ ] 移动端：弹窗可滚动（如果内容超长）
- [ ] 深色主题：样式正确
- [ ] 浅色主题：样式正确
- [ ] 事件回调：@confirm、@close 等事件正确触发

---

## ⏱️ 工作量估计

| 阶段 | 涉及文件 | 预计改动量 |
|------|----------|-----------|
| 第一阶段 | 2个 | 小（新增代码） |
| 第二阶段 | 3个 | 中（修改调用方式） |
| 第三阶段 | 5个 | 大（涉及回调传递） |
| 第四阶段 | 5个 | 小（删除代码） |

**总计**：约 10-15 个文件需要修改

---

## 🔄 回滚方案

每个阶段完成后 git commit，如发现问题可快速回滚到上一个稳定版本。

---

## 💡 替代方案

如果全量重构风险太高，可考虑：

1. **仅迁移问题弹窗**
   - 只迁移 Dashboard 中的 RowEditDialog、HistoryDialog
   - 其他嵌套弹窗保持不变，使用 `position: fixed` + `100vw/100vh` 修复

2. **使用 Provide/Inject 传递弹窗控制**
   - 父组件 provide 弹窗状态
   - 子组件 inject 后调用
   - 避免 Store 过度膨胀

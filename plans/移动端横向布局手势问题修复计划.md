# 移动端横向布局手势问题修复计划

## 问题概述

用户报告了移动端横向布局下手势功能存在多个问题，主要表现为**视觉反馈与实际触发操作不一致**。

---

## 核心发现：双轨制架构问题

通过代码分析，发现问题的根本原因是**视觉反馈和触发逻辑是两套独立的系统**：

| 函数 | 职责 | 依据 |
|------|------|------|
| `handleTouchMove` | 更新 `gestureType`（视觉反馈） | 实时 `deltaY` + 边缘检测 + 手势锁定 |
| `handleTouchEnd` | 触发 `onInsertRow`/`onToggleDelete` | 最终 `deltaY` + 边缘检测 |

两者各自独立计算，缺乏同步机制，导致视觉与实际不一致。

---

## 问题详细分析

### 问题3.1：横滑后改方向会触发增删行但无视觉反馈

**现象**：当第一个手势判定为横滑，随后改变方向为上/下滑，如果滚动条触顶/触底，会触发增删行但没有视觉反馈。

**代码位置**：[`useMobileGesturesNew.ts:483-493`](src/可视化表格/composables/useMobileGesturesNew.ts:483)

```typescript
// handleTouchMove 中的逻辑
if (directionLocked.value === 'horizontal') {
  if (!gestureLocked.value) {
    gestureType.value = null; // 清空视觉反馈
  }
  // 手动滚动父容器
  if (parentScrollContainer.value) {
    parentScrollContainer.value.scrollLeft = parentScrollStart.value - deltaX;
  }
  return; // 不触发自定义手势
}
```

**问题**：`handleTouchMove` 正确地不更新 `gestureType`，但 `handleTouchEnd` 缺少对 `directionLocked` 的检查：

```typescript
// handleTouchEnd 中的逻辑 - 缺少 directionLocked 检查！
if (layout === 'horizontal') {
  const isPullDown = deltaY > 0 && (scrollTop <= 0 || isShortCard);
  const isPullUp = deltaY < 0 && (scrollTop + clientHeight >= scrollHeight - 1 || isShortCard);

  if (isPullDown && deltaY > threshold) {
    onInsertRow(); // ← 即使 directionLocked === 'horizontal' 也会触发！
  }
}
```

**修复方案**：在 `handleTouchEnd` 开头增加方向锁定检查：

```typescript
// 如果方向锁定为横向，跳过纵向手势触发
if (layout === 'horizontal' && directionLocked.value === 'horizontal') {
  console.info('[ACU Card TouchEnd] 方向锁定为横向，跳过纵向手势');
  isSwiping.value = false;
  gestureType.value = null;
  return;
}
```

---

### 问题3.2：纵滑触发删除后改为下滑，新增行无视觉反馈

**现象**：对于纵滑，如果触发了上滑删除的视觉反馈，再往下滑可以取消删除并触发新增行，但新增行没有触发视觉反馈。

**代码位置**：[`useMobileGesturesNew.ts:462-471`](src/可视化表格/composables/useMobileGesturesNew.ts:462)

```typescript
// 手势锁定逻辑
if (displayHeight > 30) {
  if (!gestureLocked.value) {
    gestureType.value = newGestureType; // 只在未锁定时设置
    gestureLocked.value = true;
  }
  // 如果已锁定，保持当前手势状态，不切换
} else if (!gestureLocked.value) {
  gestureType.value = null;
}
```

**问题**：手势锁定后，`gestureType` 不再更新。但 `handleTouchEnd` 的判定基于最终 `deltaY`：

```typescript
const isPullDown = deltaY > 0 && ...; // 基于当前方向
if (isPullDown && deltaY > threshold) {
  onInsertRow(); // ← 触发新增，但 gestureType 可能还是 'delete'
}
```

**修复方案**：取消「手势锁定后不更新」的限制，改为「方向变化时更新 gestureType」：

```typescript
// 新方案：只锁定「从零开始的首次方向」，方向变化时允许更新
if (displayHeight > 30) {
  gestureType.value = newGestureType; // 始终根据当前方向更新
  if (!gestureLocked.value) {
    gestureLocked.value = true; // 标记已进入手势状态
  }
} else if (!gestureLocked.value) {
  gestureType.value = null;
}
```

但这会导致「抽搐问题」回归。需要更好的方案...

**更好的修复方案**：锁定「手势类型」而非「方向」，并在方向明确变化时解锁：

```typescript
// 检测方向变化
const currentDirection = deltaY > 0 ? 'insert' : 'delete';

if (displayHeight > 30) {
  // 如果方向明确变化（从 insert 变 delete 或反之），解锁并更新
  if (gestureLocked.value && gestureType.value !== currentDirection) {
    // 需要确认变化是有意的（不是抖动）
    if (Math.abs(deltaY) > threshold * 0.5) { // 超过阈值一半才认为是有意变化
      gestureType.value = currentDirection;
    }
  } else if (!gestureLocked.value) {
    gestureType.value = currentDirection;
    gestureLocked.value = true;
  }
} else if (!gestureLocked.value) {
  gestureType.value = null;
}
```

---

### 问题3.3：下拉增行反悔上滑时视觉反馈错误

**现象**：如果滚动条刚好触顶，下拉增行如果反悔了要上滑取消，上滑到增行视觉反馈消失时再继续上滑，增行视觉反馈反而又会出来，但实际触发的是删除/恢复功能。

**问题本质**：这是问题3.2的延续。用户操作流程：
1. 下拉 → `gestureType = 'insert'`, `gestureLocked = true`
2. 改为上滑 → `displayHeight` 减小，但 `gestureLocked = true` 所以 `gestureType` 保持 `'insert'`
3. 继续上滑超过阈值 → `displayHeight` 又增大，但仍锁定，`gestureType` 保持 `'insert'`
4. 松手 → `handleTouchEnd` 判定 `isPullUp = true`，触发删除！

**修复方案**：同问题3.2，允许方向变化时更新 `gestureType`。

---

### 问题1：滚动条触底上滑删除划不动

**现象**：如果滚动条刚好触底上滑删除就划不动，要下拉一点点才能上滑删除。

**可能原因**：边缘检测的精度问题

```typescript
// 当前检测逻辑
const isPullUp = deltaY < 0 && scrollTop + clientHeight >= scrollHeight - 1;
```

当 `scrollTop + clientHeight` 与 `scrollHeight` 完全相等时，`>= scrollHeight - 1` 是满足的。但如果有小数精度问题，可能导致判定失败。

**修复方案**：增加容错

```typescript
const isPullUp = deltaY < 0 && scrollTop + clientHeight >= scrollHeight - 2;
```

---

### 问题2：短卡片手势问题（重要）

**现象**：对于短卡片，如果滑出的上滑删除视觉反馈和卡片加在一起的高度超过容器高，上滑删除就删不了。

**根本原因**：视觉反馈元素（`.acu-pull-overlay`）是卡片内容的一部分，它的高度变化会动态改变 `scrollHeight`。

**问题流程**：
1. **touchstart**: 卡片内容短，`scrollHeight = 200px`, `clientHeight = 250px`，判定 `isShortCard = true`
2. **touchmove**: 用户上滑，`.acu-pull-bottom` 高度从 0 增加到 60px
3. 此时卡片的 `scrollHeight = 200 + 60 = 260px`
4. **touchend** 重新计算 `isShortCard`：
   - 新 `scrollHeight (260px) > clientHeight (250px) + 2`
   - 所以 `isShortCard = false`
5. 进入长卡片的判定逻辑：`isPullUp = deltaY < 0 && scrollTop + clientHeight >= scrollHeight - 1`
6. 但 `scrollTop = 0`，`clientHeight (250px) < scrollHeight (260px) - 1`，条件不满足！
7. **结果**：手势不触发

**代码位置**：
- DataCard.vue 第 161-171 行：视觉反馈元素在卡片内容末尾
- data-card.scss 第 638-647 行：`.acu-pull-overlay` 样式

```vue
<!-- 底部上划删除提示 - 作为卡片内容的一部分，会增加 scrollHeight -->
<div v-show="gestureType === 'delete'" class="acu-pull-overlay acu-pull-bottom">
```

**修复方案**：在 `touchstart` 时记录初始尺寸，后续判定基于初始尺寸

```typescript
// 新增状态
const initialScrollHeight = ref(0);
const initialClientHeight = ref(0);
const initialIsShortCard = ref(false);

const handleTouchStart = (e: TouchEvent) => {
  // ... 现有逻辑 ...

  // 【新增】记录初始尺寸（在视觉反馈元素高度为 0 时）
  initialScrollHeight.value = el.scrollHeight;
  initialClientHeight.value = el.clientHeight;
  initialIsShortCard.value = el.scrollHeight <= el.clientHeight + 2;
};

const handleTouchMove = (e: TouchEvent) => {
  // ...
  // 【修改】使用 initialIsShortCard.value 代替实时计算
  if (initialIsShortCard.value) {
    // 短卡片处理...
  }
};

const handleTouchEnd = (_e: TouchEvent) => {
  // ...
  // 【修改】使用 initialIsShortCard.value 代替实时计算
  const isShortCard = initialIsShortCard.value;

  // 后续判定不变
  const isPullDown = deltaY > 0 && (scrollTop <= 0 || isShortCard);
  const isPullUp = deltaY < 0 && (scrollTop + clientHeight >= scrollHeight - 1 || isShortCard);
};
```

**为什么不用 `position: absolute` 方案**：
1. 破坏现有的"弹簧"视觉效果（内容被推开/弹回）
2. 绝对定位时，反馈条会覆盖内容而不是推开内容
3. 滚动时定位可能不正确（相对于可视区域而非滚动内容）
4. 需要额外处理卡片 padding/布局问题

---

## 修复实施方案

### 阶段1：核心问题修复（问题3.1）

在 `handleTouchEnd` 开头增加方向锁定检查：

```typescript
const handleTouchEnd = (_e: TouchEvent) => {
  // ... 现有逻辑 ...

  // 【新增】如果方向锁定为横向，跳过纵向手势触发
  if (layout === 'horizontal' && directionLocked.value === 'horizontal') {
    console.info('[ACU Card TouchEnd] 方向锁定为横向，跳过纵向手势');
    isSwiping.value = false;
    gestureType.value = null;
    gestureLocked.value = false;
    return;
  }

  // ... 后续逻辑不变 ...
};
```

### 阶段2：视觉一致性修复（问题3.2、3.3）

重构 `handleTouchMove` 中的手势更新逻辑：

```typescript
// 新增状态：记录当前手势方向
const gestureDirection = ref<'up' | 'down' | null>(null);

// handleTouchMove 中
if (isPullDown || isPullUp) {
  if (e.cancelable) e.preventDefault();
  e.stopPropagation();

  const displayHeight = Math.abs(deltaY) * 0.6;
  const newDirection = isPullDown ? 'down' : 'up';
  const newGestureType = isPullDown ? 'insert' : 'delete';

  if (displayHeight > 30) {
    // 【修复】始终更新 gestureType 以匹配当前方向
    gestureType.value = newGestureType;
    gestureDirection.value = newDirection;
    gestureLocked.value = true;
  } else {
    // 未达到阈值时清空
    gestureType.value = null;
    gestureDirection.value = null;
    // 注意：不重置 gestureLocked，避免抽搐
  }
}
```

### 阶段3：边缘检测优化（问题1、2）

1. 增加边缘检测容错
2. 记录初始尺寸避免动态变化影响

---

## 测试场景

| 场景 | 预期行为 |
|------|---------|
| 横滑后改为上滑（触底） | 不应触发任何操作 |
| 横滑后改为下滑（触顶） | 不应触发任何操作 |
| 下拉后改为上滑 | 视觉反馈从「新增」变为「删除」，触发删除 |
| 上滑后改为下拉 | 视觉反馈从「删除」变为「新增」，触发新增 |
| 滚动条刚好触底上滑 | 正常触发删除 |
| 短卡片上滑删除 | 正常触发删除 |

---

## 实施优先级

1. **P0 - 必须修复**：问题3.1（横滑后误触发）
2. **P0 - 必须修复**：问题2（短卡片无法删除）
3. **P1 - 重要修复**：问题3.2、3.3（视觉反馈不一致）
4. **P2 - 如果容易则修复**：问题1（边缘精度）

## 代码修改位置

- `src/可视化表格/composables/useMobileGesturesNew.ts`
  - 新增状态：`initialScrollHeight`, `initialClientHeight`, `initialIsShortCard`
  - `handleTouchStart`: 记录初始尺寸
  - `handleTouchMove`: 使用初始尺寸判定短卡片，修改手势锁定逻辑
  - `handleTouchEnd`: 使用初始尺寸判定，增加 `directionLocked` 检查
  - 边缘检测相关函数：增加容错

## 完整修改清单

### 1. 新增状态变量

```typescript
// 新增：在 useCardGestures 函数开头
const initialScrollHeight = ref(0);
const initialClientHeight = ref(0);
const initialIsShortCard = ref(false);
```

### 2. 修改 handleTouchStart

```typescript
const handleTouchStart = (e: TouchEvent) => {
  const el = cardRef.value;
  if (!el) return;

  // ... 现有重置逻辑 ...

  // 【新增】记录初始尺寸
  initialScrollHeight.value = el.scrollHeight;
  initialClientHeight.value = el.clientHeight;
  initialIsShortCard.value = el.scrollHeight <= el.clientHeight + 2;

  // ... 其余现有逻辑 ...
};
```

### 3. 修改 handleTouchMove（短卡片判定）

```typescript
// 将所有 isShortCard 的实时计算
const isShortCard = scrollHeight <= clientHeight + 2;

// 替换为
const isShortCard = initialIsShortCard.value;
```

### 4. 修改 handleTouchEnd

```typescript
const handleTouchEnd = (_e: TouchEvent) => {
  const el = cardRef.value;
  if (!el) return;

  // ... 清除计时器逻辑 ...

  // 【新增】方向锁定检查
  if (layout === 'horizontal' && directionLocked.value === 'horizontal') {
    console.info('[ACU Card TouchEnd] 方向锁定为横向，跳过纵向手势');
    isSwiping.value = false;
    gestureType.value = null;
    gestureLocked.value = false;
    return;
  }

  // ... 选词模式检查 ...

  if (layout === 'horizontal') {
    const scrollTop = el.scrollTop;
    const scrollHeight = el.scrollHeight;
    const clientHeight = el.clientHeight;

    // 【修改】使用初始尺寸判定
    const isShortCard = initialIsShortCard.value;

    // ... 后续逻辑不变 ...
  }
};
```

### 5. 修改 handleTouchMove（视觉一致性）

```typescript
// 短卡片纵滑手势更新逻辑
if (initialIsShortCard.value) {
  // ... 方向锁定逻辑 ...

  if (directionLocked.value === 'vertical' || (directionLocked.value === null && Math.abs(deltaY) > 5)) {
    if (e.cancelable) e.preventDefault();
    e.stopPropagation();

    const displayHeight = Math.abs(deltaY) * 0.6;
    const newGestureType = deltaY > 0 ? 'insert' : 'delete';

    if (displayHeight > 30) {
      // 【修改】始终更新 gestureType，不受 gestureLocked 限制
      gestureType.value = newGestureType;
      gestureLocked.value = true;
    } else if (!gestureLocked.value) {
      gestureType.value = null;
    }
  }

  return;
}
```

# 表格更新状态看板开发计划

## 功能概述

为仪表盘创建一个可滚动的表格看板，显示每个表格的更新状态信息，包括：
- 表格名称
- 更新频率（来自模板配置）
- 未记录楼层（基于 lastUpdatedAiFloor 计算）

参考效果：类似数据库原生的状态表格显示。

---

## 一、创建 useTableUpdateStatus Composable

### 1.1 文件位置
`src/可视化表格/composables/useTableUpdateStatus.ts`

### 1.2 类型定义

```typescript
/**
 * 表格更新状态项
 */
export interface TableUpdateStatus {
  /** 表格 key (如 sheet_0) */
  sheetKey: string;
  /** 表格名称 */
  name: string;
  /** 更新频率 (-1=沿用全局, 0=禁用, >0=实际频率) */
  updateFrequency: number;
  /** 有效频率（已解析全局默认值） */
  effectiveFrequency: number;
  /** 上次更新的 AI 楼层号 (从1开始计数，0 = 从未更新) */
  lastUpdatedAiFloor: number;
  /** 上次更新的 chat 数组索引 (实际楼层号，从0开始，-1 = 从未更新) */
  lastUpdatedChatIndex: number;
  /** 未记录楼层数（基于 AI 楼层计算） */
  unrecordedFloors: number;
  /** 当前总 AI 楼层数 */
  totalAiFloors: number;
  /** 当前总楼层数（chat.length） */
  totalFloors: number;
  /** 是否已找到历史更新记录 */
  hasHistory: boolean;
  /** 是否是总结/大纲表 */
  isSummaryOrOutline: boolean;
  /** 表格顺序编号 */
  orderNo: number;
}

/**
 * 数据库全局设置（从 localStorage 读取）
 */
export interface DbGlobalSettings {
  /** 数据隔离是否启用 */
  dataIsolationEnabled: boolean;
  /** 数据隔离代码 */
  dataIsolationCode: string;
  /** 全局更新频率 */
  autoUpdateFrequency: number;
  /** 全局跳过楼层数 */
  skipUpdateFloors: number;
}
```

### 1.3 核心实现逻辑

#### 获取数据库全局设置

```typescript
function getDbGlobalSettings(): DbGlobalSettings {
  const w = window.parent || window;

  // 查找数据库设置存储 key
  const keys = Object.keys(w.localStorage || {});
  const settingsKey = keys.find(k => /shujuku_.*_allSettings_v2$/.test(k));

  if (!settingsKey) {
    return {
      dataIsolationEnabled: false,
      dataIsolationCode: '',
      autoUpdateFrequency: 1,
      skipUpdateFloors: 0,
    };
  }

  try {
    const settings = JSON.parse(w.localStorage.getItem(settingsKey) || '{}');
    return {
      dataIsolationEnabled: !!settings.dataIsolationEnabled,
      dataIsolationCode: settings.dataIsolationCode || '',
      autoUpdateFrequency: settings.autoUpdateFrequency ?? 1,
      skipUpdateFloors: settings.skipUpdateFloors ?? 0,
    };
  } catch {
    return {
      dataIsolationEnabled: false,
      dataIsolationCode: '',
      autoUpdateFrequency: 1,
      skipUpdateFloors: 0,
    };
  }
}
```

#### 计算单个表格的 lastUpdatedAiFloor

此逻辑来源于数据库代码 `.kilocode/数据库/10.5index .js` 第 6882-6950 行：

```typescript
function getLastUpdatedAiFloor(
  sheetKey: string,
  chat: STChatMessage[],
  settings: DbGlobalSettings
): { floor: number; hasHistory: boolean } {
  const currentIsolationKey = settings.dataIsolationEnabled
    ? settings.dataIsolationCode
    : '';

  // 从后向前扫描聊天记录
  for (let i = chat.length - 1; i >= 0; i--) {
    const msg = chat[i];
    if (msg.is_user) continue;

    let wasUpdated = false;

    // [优先级1] 检查新版隔离数据 TavernDB_ACU_IsolatedData
    const isolatedData = msg.TavernDB_ACU_IsolatedData;
    if (isolatedData && isolatedData[currentIsolationKey]) {
      const tagData = isolatedData[currentIsolationKey];
      const updateGroupKeys = tagData.updateGroupKeys || [];
      const modifiedKeys = tagData.modifiedKeys || [];
      const independentData = tagData.independentData || {};

      if (updateGroupKeys.length > 0 && modifiedKeys.length > 0) {
        wasUpdated = updateGroupKeys.includes(sheetKey);
      } else if (modifiedKeys.includes(sheetKey)) {
        wasUpdated = true;
      } else if (independentData[sheetKey]) {
        wasUpdated = true;
      }
    }

    // [优先级2] 兼容旧版存储格式
    if (!wasUpdated) {
      const msgIdentity = msg.TavernDB_ACU_Identity;
      let isLegacyMatch = false;

      if (settings.dataIsolationEnabled) {
        isLegacyMatch = (msgIdentity === settings.dataIsolationCode);
      } else {
        isLegacyMatch = !msgIdentity;
      }

      if (isLegacyMatch) {
        const modifiedKeys = msg.TavernDB_ACU_ModifiedKeys || [];
        const updateGroupKeys = msg.TavernDB_ACU_UpdateGroupKeys || [];

        if (updateGroupKeys.length > 0 && modifiedKeys.length > 0) {
          wasUpdated = updateGroupKeys.includes(sheetKey);
        } else if (modifiedKeys.includes(sheetKey)) {
          wasUpdated = true;
        } else if (msg.TavernDB_ACU_IndependentData?.[sheetKey]) {
          wasUpdated = true;
        }
      }
    }

    if (wasUpdated) {
      // 计算这是第几个 AI 回复
      const floor = chat.slice(0, i + 1).filter(m => !m.is_user).length;
      return { floor, hasHistory: true };
    }
  }

  return { floor: 0, hasHistory: false };
}
```

#### Composable 主函数

```typescript
export function useTableUpdateStatus() {
  const statusList = ref<TableUpdateStatus[]>([]);
  const isLoading = ref(false);
  const lastRefreshTime = ref<Date | null>(null);

  /**
   * 刷新所有表格的更新状态
   */
  async function refresh(): Promise<TableUpdateStatus[]> {
    isLoading.value = true;

    try {
      const api = getCore().getDB();
      const tableData = api?.exportTableAsJson?.();

      if (!tableData) {
        statusList.value = [];
        return [];
      }

      // 获取全局设置
      const settings = getDbGlobalSettings();

      // 获取聊天记录
      const w = window.parent || window;
      const chat: STChatMessage[] = (w as any).SillyTavern?.getContext?.()?.chat || [];
      const totalAiFloors = chat.filter(m => !m.is_user).length;

      const results: TableUpdateStatus[] = [];

      // 遍历所有表格
      const sheetKeys = Object.keys(tableData)
        .filter(k => k.startsWith('sheet_'))
        .sort((a, b) => {
          const orderA = tableData[a]?._acu_orderNo ?? Infinity;
          const orderB = tableData[b]?._acu_orderNo ?? Infinity;
          return orderA - orderB;
        });

      for (const sheetKey of sheetKeys) {
        const table = tableData[sheetKey];
        if (!table?.name) continue;

        const updateConfig = table.updateConfig || {};
        const rawFreq = updateConfig.updateFrequency ?? -1;
        const effectiveFreq = rawFreq === -1 ? settings.autoUpdateFrequency : rawFreq;

        // 计算上次更新楼层
        const { floor: lastUpdatedAiFloor, hasHistory } = getLastUpdatedAiFloor(
          sheetKey,
          chat,
          settings
        );

        // 计算未记录楼层
        const unrecordedFloors = totalAiFloors - lastUpdatedAiFloor;

        // 判断是否是总结/大纲表
        const name = table.name || sheetKey;
        const isSummaryOrOutline =
          name.includes('总结') ||
          name.includes('大纲') ||
          name.toLowerCase().includes('summary') ||
          name.toLowerCase().includes('outline');

        results.push({
          sheetKey,
          name,
          updateFrequency: rawFreq,
          effectiveFrequency: effectiveFreq,
          lastUpdatedAiFloor,
          unrecordedFloors,
          totalAiFloors,
          hasHistory,
          isSummaryOrOutline,
          orderNo: table._acu_orderNo ?? 999,
        });
      }

      statusList.value = results;
      lastRefreshTime.value = new Date();
      return results;
    } catch (e) {
      console.error('[ACU] 获取表格更新状态失败:', e);
      statusList.value = [];
      return [];
    } finally {
      isLoading.value = false;
    }
  }

  return {
    statusList: readonly(statusList),
    isLoading: readonly(isLoading),
    lastRefreshTime: readonly(lastRefreshTime),
    refresh,
  };
}
```

---

## 二、仪表盘表格看板组件

### 2.1 组件设计

在 Dashboard.vue 中添加一个新的卡片组件，显示表格更新状态列表。

### 2.2 UI 结构

**表格显示 4 列：**
| 表格名称 | 更新频率 | 未记录楼层 | 上次更新 |
|----------|----------|------------|----------|
| 设定栏 | 2 | 48 | 95/332 |
| 重要人物表 | 2 | 2 | 189/378 |

**上次更新列格式：** `AI楼层号/实际楼层号`
- AI楼层号：从 1 开始计数的 AI 消息序号
- 实际楼层号：chat 数组索引（从 0 开始）

```vue
<div class="acu-status-board">
  <div class="acu-status-header">
    <span class="acu-status-title">
      <i class="fas fa-sync-alt"></i> 表格更新状态
    </span>
    <span class="acu-status-summary">
      共 {{ statusList.length }} 个表格
    </span>
  </div>

  <div class="acu-status-table-wrapper">
    <table class="acu-status-table">
      <thead>
        <tr>
          <th>表格名称</th>
          <th>更新频率</th>
          <th>未记录楼层</th>
          <th>上次更新</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="item in statusList" :key="item.sheetKey">
          <td class="acu-status-name">{{ item.name }}</td>
          <td class="acu-status-freq">
            {{ item.effectiveFrequency === 0 ? '禁用' : item.effectiveFrequency }}
          </td>
          <td class="acu-status-unrecorded" :class="getUnrecordedClass(item)">
            {{ item.hasHistory ? item.unrecordedFloors : '—' }}
          </td>
          <td class="acu-status-last-update">
            <!-- 显示格式: AI楼层号/实际楼层号 -->
            {{ item.hasHistory
                ? `${item.lastUpdatedAiFloor}/${item.lastUpdatedChatIndex}`
                : '未初始' }}
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</div>
```

### 2.3 样式要点

```scss
.acu-status-board {
  background: var(--acu-card-bg);
  border-radius: 12px;
  overflow: hidden;
}

.acu-status-table-wrapper {
  max-height: 200px;
  overflow-y: auto;
}

.acu-status-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;

  th, td {
    padding: 8px 12px;
    text-align: left;
    border-bottom: 1px solid var(--acu-border);
  }

  th {
    background: var(--acu-table-head);
    position: sticky;
    top: 0;
    z-index: 1;
  }

  tr:hover td {
    background: var(--acu-table-hover);
  }
}

.acu-status-unrecorded {
  &.warning { color: #ffb85c; }
  &.danger { color: #ff6b6b; }
  &.success { color: #4ad19f; }
}
```

---

## 三、实施步骤

1. **创建 composable 文件**: `useTableUpdateStatus.ts`
2. **添加类型定义**: 在文件顶部定义接口
3. **实现核心逻辑**:
   - `getDbGlobalSettings()` - 读取数据库全局设置
   - `getLastUpdatedAiFloor()` - 扫描聊天记录计算更新楼层
   - `useTableUpdateStatus()` - 主 composable
4. **导出到 index.ts**
5. **在仪表盘中使用**: 创建表格看板 UI
6. **添加样式**: 在 `dashboard.scss` 中添加相关样式

---

## 四、关键数据来源说明

| 数据 | 来源 | 备注 |
|------|------|------|
| 表格列表 | `api.exportTableAsJson()` | 返回 `{ sheet_0: {...}, sheet_1: {...} }` |
| updateFrequency | `table.updateConfig.updateFrequency` | -1=全局, 0=禁用, >0=实际值 |
| 全局频率 | `localStorage[shujuku_*_allSettings_v2].autoUpdateFrequency` | 默认 1 |
| lastUpdatedAiFloor | 扫描 `chat[i].TavernDB_ACU_IsolatedData` | AI 消息序号（从1开始） |
| lastUpdatedChatIndex | 扫描时记录的 chat 索引 i | 实际楼层号（从0开始） |
| 总 AI 楼层 | `chat.filter(m => !m.is_user).length` | 统计非用户消息 |
| 总楼层 | `chat.length` | 聊天记录总数 |

---

## 五、注意事项

1. **数据隔离**: 必须正确处理 `dataIsolationEnabled` 和 `dataIsolationCode`，否则会读到错误的数据
2. **兼容旧格式**: 需要同时检查 `TavernDB_ACU_IsolatedData` (新) 和 `TavernDB_ACU_IndependentData` (旧)
3. **性能**: 扫描聊天记录可能较慢，建议加防抖或缓存
4. **响应式更新**: 监听 `_notifyTableUpdate` 回调来自动刷新状态
